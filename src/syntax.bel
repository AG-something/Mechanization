%{----------------------------------------------------------------------------------------------
        Syntax and inference rules of a dependently-typed λ-calculus with unit types and subtyping
               Source :   Stone, C.A.,  Harper, R. (2006). Extensional Equivalence and Singleton Types.  pp. 4-14.

               Author : Antoine Gaulin

--------------------------------------------------------------------------------------------------
  Syntax of expressions
     Typing Contexts    Γ, Δ ∷=   .             Empty context
                                | Γ, x:A        Context extension

     Types              A, B ∷=   b             Base type 
                                | S(M)          Singleton type
		                | S_A(M)        Labelled singleton type  (admissible)
                	        | Πx:A. A'      Dependent function type
		                | Σx:A. A'      Dependent pair type

     Terms              M, N ∷=   c             Constants
                                | x             Variables
				| λx:A. M       Function abstraction
                                | M M'          Function application
				| <M, M'>       Pairs
				| π_i(M)        Projections
----------------------------------------------------------------------------------------------}%
% Natural numbers (to index the constants)
LF nat : type = 
  | zero : nat
  | succ : nat → nat
;

% Terms
LF tm : type = 
  | const : nat → tm
  | lam : tp → ( tm → tm ) → tm
  | app : tm → tm → tm
  | pair : tm → tm → tm
  | proj1 : tm → tm
  | proj2 : tm → tm

and
% Types
tp : type =
  | base : tp
  | sing : tm → tp
  | pi : tp → ( tm → tp ) → tp
  | sigma : tp → ( tm → tp ) → tp

  % Admissible
  | label_sing : tp → tm → tp
;


%{---------------------------------------------------------------------------------------------
    Judgments :
               Well-formed types                          Γ ⊢ A                                   Γ ⊢ wf_tp A
               Subtypes                                           Γ ⊢ A < B                            Γ ⊢ sub_tp A B
               Declarative equality of types        Γ ⊢ A == B                          Γ ⊢ deq_tp A B

               Well-typed terms                             Γ ⊢ M : A                            Γ ⊢ wt_tm M A
               Declarative equality of terms        Γ ⊢ M == N : A                   Γ ⊢ deq_tm M N A

               Well-formed context                       Γ ⊢ ok                                 This we get for free?
----------------------------------------------------------------------------------------------}%
% The judgments are defined by simultaneous induction

% Well-formed types
LF wf_tp : tp → type =
  | wf_base : wf_tp base
  | wf_sing : wt_tm M base 
              → wf_tp ( sing M )
  | wf_pi : ( { x : tm } { A : tp } { t_x : wt_tm x A } wf_tp ( B x ) ) 
            → wf_tp ( pi A B )
  | wf_sigma : ( { x : tm } { A : tp } {t_x : wt_tm x A } wf_tp ( B x ) ) 
                → wf_tp ( sigma A B )

  % Admissible rules
  | wf_labsing_adm : wt_tm M A
                     → wf_tp ( label_sing A M )


% Subtypes
and sub_tp : tp → tp → type =
  | sub_base : sub_tp base base
  | sub_sing_base : wt_tm M base
                    → sub_tp ( sing M ) base
  | sub_sing_eq : deq_tm M N base 
                  → sub_tp ( sing M ) ( sing N )
  | sub_pi : wf_tp ( pi A1 B1 ) 
             → sub_tp A2 A1 
             → ( { x : tm } wt_tm x A2 → sub_tp ( B1 x ) ( B2 x ) )
             → sub_tp ( pi A1 B1 ) ( pi A2 B2 )
  | sub_sigma : wf_tp ( sigma A1 B1 )
                → sub_tp A1 A2
                → ( { x : tm } wt_tm x A1 → sub_tp ( B1 x ) ( B2 x ) )
                → sub_tp ( sigma A1 B1 ) ( sigma A2 B2 )

  % Admissible rules
  | sub_wt_sing_adm : wt_tm M A 
                      → sub_tp ( label_sing A M ) A
  | sub_deq_sing_adm : deq_tm M1 M2 A1 → sub_tp A1 A2
                       → sub_tp ( label_sing A1 M1 ) ( label_sing A2 M2 )


% Declarative equality of types
and deq_tp : tp → tp → type =
  | deq_base : deq_tp base base 
  | deq_sing : deq_tm M N base
               → deq_tp ( sing M ) ( sing N )
  | deq_pi : deq_tp A1 A2
             → ( { x : tm } wt_tm x A1 → deq_tp ( B1 x ) ( B2 x ) )
             → deq_tp ( pi A1 B1 ) ( pi A2 B2 )
  | deq_sigma : deq_tp A1 A2
                → ( { x : tm } wt_tm x A1 → deq_tp ( B1 x ) ( B2 x ) )
                → deq_tp ( sigma A1 B1 ) ( sigma A2 B2 )

  % Admissible rules



% Well-typed terms
and wt_tm : tm → tp → type =
  | wt_const : { n : nat } wt_tm ( const n ) base
  | wt_sing : wt_tm M base
              → wt_tm M ( sing M )

  % Rules for functions / Π-types
  | wt_lam : ( { x : tm } { A : tp } { t_x : wt_tm x A } wt_tm ( M x ) ( B x ) )
             → wt_tm ( lam A M ) ( pi A B )
  | wt_app : wt_tm M ( pi A B )
             → wt_tm N A
             → wt_tm ( app M N ) ( B N )
  | wt_pi : ( { x : tm } { A : tp } wt_tm x A → wt_tm ( app M x ) ( B x ) )
            → wt_tm M ( pi A C ) 
            → wf_tp ( pi A C )
            → wt_tm M ( pi A B )
                    
  % Rules for pairs / Σ-types
  | wt_pair : wf_tp ( sigma A B )
              → wt_tm M A
              → wt_tm N ( B M )
              → wt_tm ( pair M N ) ( sigma A B )
  | wt_proj1 : wt_tm M ( sigma A B )
               → wt_tm ( proj1 M ) A
  | wt_proj2 : wt_tm M ( sigma A B )
               → wt_tm ( proj2 M ) ( B (proj1 M ) )
  | wt_sigma : wf_tp ( sigma A B )
               → wt_tm ( proj1 M ) A
               → wt_tm ( proj2 M ) ( B ( proj1 M ) )
               → wt_tm M ( sigma A B )

  % Subtypes
  | wt_sub : wt_tm M A
             → sub_tp A B
             → wt_tm M B

  % Admissible rules
  | wt_sing_adm : deq_tm M1 M2 base
                  → wt_tm M1 ( sing M2 )
  | wt_labsing_adm : wt_tm  M A
                     →  wt_tm M ( label_sing A M )



% Declarative equality of terms
and deq_tm : tm → tm → tp → type =
  % Axioms of equivalence
  | deq_refl : wt_tm M A 
               → deq_tm M M A
  | deq_sym : deq_tm M N A 
              → deq_tm N M A
  | deq_trans : deq_tm M1 M2 A
                → deq_tm M2 M3 A
                → deq_tm M1 M3 A

  % Rules for functions / Π-types
  | deq_lam : deq_tp A A' → ( { x : tm } wt_tm x A → deq_tm ( M x ) ( N x ) ( B x ) )
              → deq_tm ( lam A M ) ( lam A' N ) ( pi A B )
  | deq_app : deq_tm M1 N1 ( pi A B )
              → deq_tm M2 N2 A
              → deq_tm ( app M1 M2 ) ( app N1 N2 ) ( B M1 )
                                 
  % Rules for pairs / Σ-types
  | deq_pair : wf_tp ( sigma A B )
               → deq_tm M1 N1 A
               → deq_tm M2 N2 ( B M1 )
               → deq_tm ( pair M1 M2 ) ( pair N1 N2 ) ( sigma A B )
  | deq_proj1 : deq_tm M N ( sigma A B )
                → deq_tm ( proj1 M ) ( proj2 N ) A
  | deq_proj2 : deq_tm M N ( sigma A B )
                → deq_tm ( proj2 M ) ( proj2 N ) ( B ( proj1 M ) )

  % Extensional rules
  | deq_pi_ext : ( { x : tm } wt_tm x A → deq_tm ( app M x ) ( app N x ) ( B x ) )
                 → wt_tm M ( pi A C1 )
                 → wt_tm N ( pi A C2 )
                 → deq_tm M N ( pi A B )
  | deq_sigma_ext : wf_tp ( sigma A B ) 
                    → deq_tm ( proj1 M ) ( proj2 N ) A
                    → deq_tm ( proj2 M ) ( proj2 N ) ( B ( proj1 M ) )
                    → deq_tm M N ( sigma A B )

  | deq_sub : deq_tm M N A
              → sub_tp A B
              → deq_tm M N B
  | deq_sing_tm : wt_tm M ( sing N )
                  → deq_tm M N ( sing N )


  % Admissible rules
  | deq_base_deq_adm : deq_tm M1 M2 base 
                         →deq_tm M1 M2 ( sing M2 )
  | deq_sing_elim_adm : wt_tm M1 ( sing M2 )
                        → deq_tm M1 M2 base

  | deq_in_labsing_adm : wt_tm M2 A → wt_tm M1 ( label_sing A M2 )
  | deq_labsing_adm : deq_tm M1 M2 A
                      → deq_tm M1 M2 ( label_sing A M2 )

  % β and η rules (admissibles)
  | deq_beta_app : ( { x : tm } { A : tp } wt_tm x A → wt_tm ( M x ) ( B x ) ) → wt_tm M' A
                   → deq_tm ( app ( lam A M )  M' ) ( M M' ) ( B M')
  | deq_beta_proj1 : wt_tm M1 A1 → wt_tm M2 A2
                     → deq_tm ( proj1 ( pair  M1 M2 ) ) M1 A1
  | deq_beta_proj2 : wt_tm M1 A1 → wt_tm M2 A2
                     → deq_tm ( proj2 ( pair  M1 M2 ) ) M2 A2
  | deq_eta_lam : wt_tm M ( pi A ( \x. B ) )
                  → deq_tm M ( lam A (\x. app M x ) ) ( pi A ( \x. B ) )
  | deq_eta_pair : wt_tm M ( sigma A ( \x. B ) )
                   → deq_tm M ( pair ( proj1 M ) ( proj2 M ) ) ( sigma A ( \x. B ) )
;


% And finally, we can define typing contexts : 
schema tctx = some [ t_A : wf_tp A ] block ( x : tm , A : tp, t : wt_tm x A );

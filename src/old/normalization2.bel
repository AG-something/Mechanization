%{----------------------------------------------------------------------------------------------
           Algorithmic judgments for normalization of terms and types
               Source :   Stone, C.A.,  Harper, R. (2006). Extensional Equivalence and Singleton Types.  pp. 21-22.

               Author : Antoine Gaulin

--------------------------------------------------------------------------------------------------
  This section introduces "algorithmic" inference rules to compute normal forms of terms and types
  These new rules define six additional judgments in the language, which depend on the notions of 'elimination contexts' and 'paths'
      (1) An elimination is a series of applications to and projection from the context hole ( denoted <> )
            They are formally defined via the following syntax : 
                                           ε  ∷=  <>
                                                    | ε M
                                                    | π1 ε
                                                    | π2 ε
          Given an elimination context ε, we write ε[M] to denote the term resuting from filling <> with M
}%

LF elim_ctx : ( tm → tm ) → type =
  | e_hole : elim_ctx ( \x. x )
  | e_app : elim_ctx E
                   → elim_ctx ( \x. app ( E x ) M )
  | e_proj1 : elim_ctx E 
                      → elim_ctx ( \x. proj1 ( E x ) )
  | e_proj2 : elim_ctx E
                      → elim_ctx ( \x. proj2 ( E x ) )
;

LF redex : tm → tm → type =
  | r_beta : redex ( app ( lam _ M ) M' ) ( M M' )
  | r_proj1 : redex ( proj1 ( pair M1 M2 ) ) M1
  | r_proj2 : redex ( proj2 ( pair M1 M2 ) ) M2
;


%{--------------------------------------------------------------------------------------------
  And now, we can define the judgments :
     (1)    Γ ⊢ p /\ A                 Path p has natural type A                                           *  /\ represents an upward arrow
     (2)    Γ ⊢ M ~> M'            Term M head reduces to term M'
     (3)    Γ ⊢ M \/ N               Term M has head normal form N                                * \/ represents a downward arrow
     (4)    Γ ⊢ M : A ⇒ M'       Term M has normal form M' at type A
     (5)    Γ ⊢ p → p' /\ A        Path p has normal form p' at natural type A
     (6)    Γ ⊢ A ⇒ B                Type A has normal form B
  
   * These are algorithmic in the sense that the judgment " Γ ⊢ E # E'  ", where # is one of the arrows, 
       can be interpreted as computing E' given Γ and E as inputs
----------------------------------------------------------------------------------------------}%

inductive nat_tp : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tp ] → ctype =
  | nt_const : nat_tp [ Γ ⊢ const n ] [ Γ ⊢ base ]
  | nt_var : nat_tp [ Γ ⊢  #b.1 ]  [ Γ ⊢ #b.2 ]
  | nt_proj1 : nat_tp [ Γ ⊢ p ] [ Γ ⊢ sigma A ( \x. B ) ]
                       → nat_tp [ Γ ⊢ proj1 p ] [ Γ ⊢ A ]
  | nt_proj2 : nat_tp [ Γ ⊢ p ] [ Γ ⊢ sigma A ( \x. B ) ]
                       → nat_tp [ Γ ⊢ proj2 p ] [ Γ ⊢ B[.., (proj1 p)] ]
  | nt_app : nat_tp [ Γ ⊢ p ] [ Γ ⊢ pi A (\x. B ) ]
                     → nat_tp [ Γ ⊢ app p M ] [ Γ ⊢ B[.. , M ] ]
;


inductive head_red : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tm ] → ctype =
  | hr_redex : { E : [ Γ , x : tm ⊢ tm ] } [ Γ ⊢ elim_ctx ( \x. E ) ] → [ Γ ⊢ redex M1 M2 ]
                        → head_red [ Γ ⊢ E[.., M1] ] [ Γ ⊢ E[.., M2 ] ]
  | hr_path : [ Γ ⊢ elim_ctx ( \x. E ) ] → nat_tp [ Γ ⊢ p ] [ Γ ⊢ sing N ]
                      → head_red [ Γ ⊢ E[.., p] ] [ Γ ⊢ E[.., N ] ]
;


LF not_possible : type =
;

inductive head_norm : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tm ] → ctype =
  | hn_step : head_red [ Γ ⊢ M ] [ Γ ⊢ M' ] → head_norm [ Γ ⊢ M' ] [ Γ ⊢ N ]
                      → head_norm [ Γ ⊢ M ] [ Γ ⊢ N ]
  | hn_nostep : ( { N : [ Γ ⊢ tm ] } head_red [ Γ ⊢ M ] [ Γ ⊢ N ] → [ Γ ⊢ not_possible ] )
                           → head_norm [ Γ ⊢ M ] [ Γ ⊢ M ]
;


inductive tm_norm : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tp ] → [ Γ ⊢ tm ] → ctype =
  | tmn_base : head_norm [ Γ ⊢ M ] [ Γ ⊢ M' ] 
                          → path_norm [ Γ ⊢ M' ] [ Γ ⊢ M'' ] [ Γ ⊢ base ]
                          → tm_norm [ Γ ⊢ M ] [ Γ ⊢ base ] [ Γ ⊢ M'' ]

  | tmn_sing : head_norm [ Γ ⊢ M ] [ Γ ⊢ M' ] 
                          → path_norm [ Γ ⊢ M' ] [ Γ ⊢ M'' ] [ Γ ⊢ sing N ]
                          → tm_norm [ Γ ⊢ M ] [ Γ ⊢ sing N ] [ Γ ⊢ M'' ]

  | tmn_pi : tp_norm [ Γ ⊢ A ] [ Γ ⊢ A' ] 
                     → tm_norm [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ app M[..] b.1 ]
                                            [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B[..] ]
                                            [ Γ , b : block ( x : tm , A : tp  , t_x : wt_tm x A ) ⊢ N[.., b.1] ]
                     → tm_norm [ Γ ⊢ M[..] ] [ Γ ⊢ pi A ( \x. B[..] ) ] [ Γ ⊢ lam A' ( \x. N[..] ) ]

  | tmn_sigma : tm_norm [ Γ ⊢ proj1 M ] [ Γ ⊢ A ] [ Γ ⊢ N1 ]
                            → tm_norm [ Γ ⊢ proj2 M ] [ Γ ⊢ B[.., proj1 M ] ] [ Γ ⊢ N2 ]
                            → tm_norm [ Γ ⊢ M ] [ Γ ⊢ sigma A ( \x. B ) ] [ Γ ⊢ pair N1 N2 ]


and inductive path_norm : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tm ] → [ Γ ⊢ tp ] → ctype =
      | pn_const : path_norm [ Γ ⊢ const n ] [ Γ ⊢ const n ] [ Γ ⊢ base ]
      | pn_var : path_norm [ Γ ⊢ #b.1 ] [ Γ ⊢ #b.1 ] [ Γ ⊢ #b.2 ]

      | pn_app : path_norm [ Γ ⊢ p  ] [ Γ ⊢ p' ] [ Γ ⊢ pi A ( \x. B ) ]
                          → tm_norm [ Γ ⊢ M ] [ Γ ⊢ A ] [ Γ ⊢ M' ]
                          → path_norm [ Γ ⊢ app p M ] [ Γ ⊢ app p' M' ] [ Γ ⊢ B[.., M] ]

      | pn_proj1 : path_norm  [ Γ ⊢ p ] [ Γ ⊢ p' ] [ Γ ⊢ sigma A ( \x. B ) ]
                            → path_norm [ Γ ⊢ proj1 p ]  [ Γ ⊢ proj1 p' ] [ Γ ⊢ A ]

      | pn_proj2 : path_norm [ Γ ⊢ p ] [ Γ ⊢ p' ] [ Γ ⊢ sigma A ( \x. B ) ] 
                            → path_norm [ Γ ⊢ proj2 p ] [ Γ ⊢ proj2 p' ] [ Γ ⊢ B[.., p] ]


and inductive tp_norm : ( Γ : tctx ) [ Γ ⊢ tp ] → [ Γ ⊢ tp ] → ctype = 
      | tpn_base : tp_norm [ Γ ⊢ base ] [ Γ ⊢ base ]

      | tpn_sing : tm_norm [ Γ ⊢ M ] [ Γ ⊢ base ] [ Γ ⊢ M' ]
                           → tp_norm [ Γ ⊢ sing M ] [ Γ ⊢ sing M' ]

      | tpn_pi : tp_norm [ Γ ⊢ A ] [ Γ ⊢ A' ]
                        → tp_norm [ Γ, b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B[.., b.1 ] ] [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B'[.., b.1] ]
                        → tp_norm [ Γ ⊢ pi A ( \x. B ) ] [ Γ ⊢ pi A' ( \x. B' ) ]

      | tpn_sigma :  tp_norm [ Γ ⊢ A ] [ Γ ⊢ A' ]
                        → tp_norm [ Γ, b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B[.., b.1 ] ] [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B'[.., b.1] ]
                        → tp_norm [ Γ ⊢ sigma A ( \x. B ) ] [ Γ ⊢ sigma A' ( \x. B' ) ]
;



%{----------------------------------------------------------------------------------------------
       Lemma 4.1 ( Determinacy )
             (1) If  Γ ⊢ p /\ A   and  Γ ⊢ p /\ B , then  A = B
             (+) If  Γ ⊢ M \/ N1  and  Γ ⊢ M \/ N2 ,  then N1 = N2                   ( * this is not in the paper, but I think it's needed for (2)  )
             (2) If  Γ ⊢ M : A ⇒ N1  and  Γ ⊢ M : A ⇒ N2 , then N1 = N2
             (3) If Γ ⊢ p → p1 /\ A1  and  Γ ⊢ p → p2 /\  A2 , then  A1 = A2
             (4) If Γ ⊢ A ⇒ B1  and  Γ ⊢ A ⇒ B2 , then  B1 = B2

        * What notion of equality is used in this?
            I think it's just defined by reflexivity ( up to renaming of bound variables )
----------------------------------------------------------------------------------------------}%
%{
LF tm_eq : tm → tm → type =
  | tm_refl : tm_eq M M
;

LF tp_eq : tp → tp → type =
  | tp_refl : tp_eq A A
;


rec nat_tp_det : ( Γ : tctx ) nat_tp [ Γ ⊢ p ] [ Γ ⊢ A ] → nat_tp [ Γ ⊢ p ] [ Γ ⊢ A' ]
                               → [ Γ ⊢ tp_eq A A' ] =
/ total d ( nat_tp_det γ p a a' d e ) /
fn d , e ⇒ case  d of
  | nt_const ⇒ 
        let nt_const  = e in
        [ _ ⊢ tp_refl ]

  | nt_var ⇒ 
        let nt_var = e in 
        [ _ ⊢ tp_refl ]

  | nt_proj1 NT ⇒ 
        let nt_proj1 NT' = e in
        let [ Γ ⊢ tp_refl ] = nat_tp_det NT NT' in 
        [ Γ ⊢ tp_refl ]

  | nt_proj2 NT ⇒ 
        let nt_proj2 NT' = e in
        let [ _ ⊢ tp_refl ] = nat_tp_det  NT NT' in
        [ _ ⊢ tp_refl ]

  | nt_app NT ⇒ 
        let nt_app NT' = e in
        let [ _ ⊢ tp_refl ] = nat_tp_det NT NT' in 
        [ _ ⊢ tp_refl ]
;


% To show that term normalization is deterministic, we need additional lemmas 
inductive common_step : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tm ] → ctype =
  | common : head_red [ Γ ⊢ M1 ] [ Γ ⊢ M ] → head_red [ Γ ⊢ M2 ] [ Γ ⊢ M ]
                        → common_step [ Γ ⊢ M1 ] [ Γ ⊢ M2 ]
  | common_refl : [ Γ ⊢ tm_eq M1 M2 ]
                                → common_step [ Γ ⊢ M1 ] [ Γ ⊢ M2 ]
;


rec diamond_property : ( Γ : tctx ) head_red [ Γ ⊢ M ] [ Γ ⊢ M1 ] → head_red [ Γ ⊢ M ] [ Γ ⊢ M2 ] 
                           → common_step [ Γ ⊢ M1 ] [ Γ ⊢ M2 ] = 
/ total d ( diamond_property γ m m1 m2 d e ) /
fn d , e ⇒ case d of
    | hr_redex E1 R1 ⇒ ?
    | hr_path E1 NT1 ⇒ ?
;
}%

%{
          ( case e of
            | hr_redex E2 R2 ⇒ 
                  ( case E1 of
                    | [ Γ ⊢ e_hole ] ⇒ 
                          ( case E2 of
                            | [ Γ ⊢ e_hole ] ⇒ ?
                            | [ Γ ⊢ e_app E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj1 E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj2 E2' ] ⇒ ?
                          )

                    | [ Γ ⊢ e_app E1' ] ⇒ 
                          ( case E2 of
                            | [ Γ ⊢ e_hole ] ⇒ ?
                            | [ Γ ⊢ e_app E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj1 E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj2 E2' ] ⇒ ?
                          )

                    | [ Γ ⊢ e_proj1 E1' ] ⇒ 
                          ( case E2 of
                            | [ Γ ⊢ e_hole ] ⇒ ?
                            | [ Γ ⊢ e_app E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj1 E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj2 E2' ] ⇒ ?
                          )

                    | [ Γ ⊢ e_proj2 E1' ] ⇒ 
                          ( case E2 of
                            | [ Γ ⊢ e_hole ] ⇒ ?
                            | [ Γ ⊢ e_app E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj1 E2' ] ⇒ ?
                            | [ Γ ⊢ e_proj2 E2' ] ⇒ ?
                          )
                  )


            | hr_path E2 NT ⇒ 
                  ( case E1 of
                    | [ Γ ⊢ e_hole ] ⇒ ?
                    | [ Γ ⊢ e_app E1' ] ⇒ ?
                    | [ Γ ⊢ e_proj1 E1' ] ⇒ ?
                    | [ Γ ⊢ e_proj2 E1' ] ⇒ ?
                  )
          )

  | hr_beta [ Γ ⊢ E ] ⇒ ?
        ( case e of 
            | hr_beta [ Γ ⊢ E' ] ⇒ ?
            | hr_proj1 [ Γ ⊢ E' ] ⇒ ?
            | hr_proj2 [ Γ ⊢ E' ] ⇒ ?
            | hr_path [ Γ ⊢ E' ] ⇒ ?
        )
  | hr_proj1 [ Γ ⊢ E ] ⇒ ?
  | hr_proj2 [ Γ ⊢ E ] ⇒ ?
}%

%{
rec bwd_closed_HNF : ( Γ : tctx ) head_red [ Γ ⊢ M ] [ Γ ⊢ M' ] → head_norm [ Γ ⊢ M ] [ Γ ⊢ N ]
                                           → head_norm [ Γ ⊢ M' ] [ Γ ⊢ N ] =
/ total e ( bwd_closed_HNF γ m m' n d e ) /
fn d , e ⇒ case e of 
  | hn_step HR HN ⇒ ?
}%
%{
       ***** This broke when I added reflexivity to common_step (case coverage failure)
        let common HR1 HR2 = diamond_property d HR in 
        let HN' = bwd_closed_HNF HR2 HN in
        hn_step HR1 HN'
}%
%{
  | hn_nostep F ⇒ 
        let ( d : head_red [ Γ ⊢ M ] [ Γ ⊢ M' ] ) = d in
        impossible ( F [ Γ ⊢ M' ] d )
;
}%

%{
rec head_norm_det : ( Γ : tctx ) head_norm [ Γ ⊢ M ] [ Γ ⊢ N1 ] → head_norm [ Γ ⊢ M ] [ Γ ⊢ N2 ] 
                                        → [ Γ ⊢ tm_eq N1 N2 ] =
/ total d ( head_norm_det γ m n1 n2 d e ) /
fn d , e ⇒ case d of
  | hn_step HR HN ⇒ 
        let hn_step HR' HN' = e in ?
}%
%{
       ***** This broke when I added reflexivity to common_step (case coverage failure)
        let common HR1 HR2 = diamond_property HR HR' in 
        let HN1 = bwd_closed_HNF HR1 HN in
        let HN2 = bwd_closed_HNF HR2 HN' in 
        let HN3 = hn_step HR1 HN2 in
        head_norm_det HN HN3                                                
}%
%{
  | hn_nostep F ⇒ 
        ( case e of
          | hn_step HR' HN' ⇒
                let ( HR' : head_red [ Γ ⊢ M ] [ Γ ⊢ M' ] ) = HR' in 
                impossible ( F [ Γ ⊢ M' ] HR' )
          | hn_nostep F' ⇒
                [ _ ⊢ tm_refl ]
        )
;
}%



%{
rec tm_norm_det : ( Γ : tctx ) tm_norm [ Γ ⊢ M ] [ Γ ⊢ A ] [ Γ ⊢ N1 ]  → tm_norm [ Γ ⊢ M ] [ Γ ⊢ A ] [ Γ ⊢ N2 ]
                                    → [ Γ ⊢ tm_eq N1 N2 ] =
/ total d ( tm_norm_det γ m a n1 n2 d e ) /
fn d , e ⇒ case d of 
  | tmn_base HN PN ⇒ 
        let tmn_base HN' PN' = e in
        let [ _ ⊢ tm_refl ] = head_norm_det HN HN' in
        let [ _ ⊢ tm_refl ] = path_norm_det1 PN PN' in
        [ _ ⊢ tm_refl ]

  | tmn_sing HN PN ⇒ 
        let tmn_sing HN' PN' = e in 
        let [ _ ⊢ tm_refl ] = head_norm_det HN HN' in
        let [ _ ⊢ tm_refl ] = path_norm_det1 PN PN' in
        [ _ ⊢ tm_refl ]

  | tmn_pi TPM TMN ⇒ 
        let tmn_pi TPM' TMN' = e in
        let [ _  ⊢ tp_refl ] = tp_norm_det TPM TPM' in 
        let [ _ , b : block ( x : tm , A : tp , t : wt_tm x A ) ⊢ tm_refl ] =  tm_norm_det TMN TMN' in
        [ _ ⊢ tm_refl ]

  | tmn_sigma TMN1 TMN2 ⇒ 
        let tmn_sigma TMN1' TMN2' = e in
        let [ _ ⊢ tm_refl ] = tm_norm_det TMN1 TMN1' in
        let [ _ ⊢ tm_refl ] = tm_norm_det TMN2 TMN2' in 
        [ _ ⊢ tm_refl ]


and rec path_norm_det1 : ( Γ : tctx ) path_norm [ Γ ⊢ p ] [ Γ ⊢ p1 ] [ Γ ⊢ A1 ] → path_norm [Γ ⊢ p ] [Γ ⊢ p2 ] [ Γ ⊢ A2 ]
                                                 → [ Γ ⊢ tm_eq p1 p2 ] = 
/ total d ( path_norm_det1 γ p p1 a1 p2 a2 d e ) /
fn d , e ⇒ case d of
      | pn_const ⇒ 
            let pn_const = e in
            [ _ ⊢ tm_refl ]

      | pn_var ⇒ 
            let pn_var = e in 
            [ _ ⊢tm_refl ]

      | pn_app PN TMN ⇒
            let pn_app PN' TMN' = e in
            let [ _ ⊢ tm_refl ] = path_norm_det1 PN PN' in
            let [ _ ⊢ tp_refl ] = path_norm_det2 PN PN' in
            let [ _ ⊢ tm_refl ] = tm_norm_det TMN TMN' in 
            [ _ ⊢ tm_refl ]

      | pn_proj1 PN ⇒
            let pn_proj1 PN' = e in
            let [ _ ⊢ tm_refl ] = path_norm_det1 PN PN' in
            [ _ ⊢ tm_refl ]

      | pn_proj2 PN ⇒ 
            let pn_proj2 PN' = e in
            let [ _ ⊢ tm_refl ] = path_norm_det1 PN PN' in
            [ _ ⊢ tm_refl ]

and rec path_norm_det2 : ( Γ : tctx ) path_norm [ Γ ⊢ p ] [ Γ ⊢ p1 ] [ Γ ⊢ A1 ] → path_norm [Γ ⊢ p ] [Γ ⊢ p2 ] [ Γ ⊢ A2 ]
                                                 → [ Γ ⊢ tp_eq A1 A2 ] = 
/ total d ( path_norm_det2 γ p p1 a1 p2 a2 d e ) /
fn d , e ⇒ case d of
      | pn_const ⇒ 
            let pn_const = e in
            [ _ ⊢ tp_refl ]

      | pn_var ⇒ 
            let pn_var = e in 
            [ _ ⊢ tp_refl ]

      | pn_app PN TMN ⇒
            let pn_app PN' TMN' = e in
            let [ _ ⊢ tp_refl ] = path_norm_det2 PN PN' in
            [ _ ⊢ tp_refl ]

      | pn_proj1 PN ⇒
            let pn_proj1 PN' = e in
            let [ _ ⊢ tp_refl ] = path_norm_det2 PN PN' in
            [ _ ⊢ tp_refl ]

      | pn_proj2 PN ⇒ 
            let pn_proj2 PN' = e in
            let [ _ ⊢ tp_refl ] = path_norm_det2 PN PN' in
            [ _ ⊢ tp_refl ]

and rec tp_norm_det : ( Γ : tctx ) tp_norm [ Γ ⊢ A ] [ Γ ⊢ B1 ] → tp_norm [ Γ ⊢ A ] [ Γ ⊢ B2 ] 
                                           → [ Γ ⊢ tp_eq B1 B2 ] = 
/ total d ( tp_norm_det γ a b1 b2 d e ) /
fn d , e ⇒ case d of
      | tpn_base ⇒ 
            let tpn_base = e in 
            [ _ ⊢ tp_refl ]

      | tpn_sing TMN ⇒ 
            let tpn_sing TMN' = e in
            let [ _ ⊢ tm_refl ] = tm_norm_det TMN TMN' in 
            [ _ ⊢ tp_refl ]

      | tpn_pi TPN1 TPN2 ⇒
            let tpn_pi TPN1' TPN2' = e in 
            let [ _ ⊢ tp_refl ] = tp_norm_det TPN1 TPN1' in 
            let [ _ , b : block ( x : tm , A : tp , t : wt_tm x A ) ⊢ tp_refl ] = tp_norm_det TPN2 TPN2' in
            [ _ ⊢ tp_refl ]

      | tpn_sigma TPN1 TPN2 ⇒
            let tpn_sigma TPN1' TPN2' = e in 
            let [ _ ⊢ tp_refl ] = tp_norm_det TPN1 TPN1' in 
            let [ _, b : block ( x : tm , A : tp , t : wt_tm x A ) ⊢ tp_refl ] = tp_norm_det TPN2 TPN2' in 
            [ _ ⊢ tp_refl ]
;

}%

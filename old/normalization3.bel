%{----------------------------------------------------------------------------------------------
        Syntax and inference rules of a dependently-typed λ-calculus with unit types and subtyping
               Source :   Stone, C.A.,  Harper, R. (2006). Extensional Equivalence and Singleton Types.  pp. 21-23.

               Author : Antoine Gaulin

--------------------------------------------------------------------------------------------------
  This section introduces "algorithmic" inference rules to compute normal forms of terms and types
  These new rules define six additional judgments in the language, which depend on the notions of 'elimination contexts' and 'paths'
      (1) An elimination is a series of applications to and projection from the context hole ( denoted <> )
            They are formally defined via the following syntax : 
                              ε  ∷=  <>
                                    | ε M
                                    | π1 ε
                                    | π2 ε
          Given an elimination context ε, we write ε[M] to denote the term resuting from filling <> with M
}%

LF elim_ctx : ( tm → tm ) → type =
  | e_hole : elim_ctx ( \x. x )
  | e_app : elim_ctx E
            → elim_ctx ( \x. app ( E x ) M )
  | e_proj1 : elim_ctx E 
              → elim_ctx ( \x. proj1 ( E x ) )
  | e_proj2 : elim_ctx E
              → elim_ctx ( \x. proj2 ( E x ) )
;


%{
     (2) A path is any term of the form ε[x] or ε[c] ( for some variable x or constant c )
           * Note that if p is a path and ε is an elimination context, then ε[p] is also a path

      **  Not sure if this will really play a role
}%

LF path : tm → type =
  | p_cons : elim_ctx E 
             → path ( E ( const n ) )
  | p_var : elim_ctx E
            → { x : tm } path ( E x )
;



%{--------------------------------------------------------------------------------------------
  And now, we can define the judgments :
     (1)    Γ ⊢ p /\ A                 Path p has natural type A                                           *  /\ represents an upward arrow
     (2)    Γ ⊢ M ~> M'            Term M head reduces to term M'
     (3)    Γ ⊢ M \/ N               Term M has head normal form N                                * \/ represents a downward arrow
     (4)    Γ ⊢ M : A ⇒ M'       Term M has normal form M' at type A
     (5)    Γ ⊢ p → p' /\ A        Path p has normal form p' at natural type A
     (6)    Γ ⊢ A ⇒ B                Type A has normal form B
  
   * These are algorithmic in the sense that the judgment " Γ ⊢ E # E'  ", where # is one of the arrows, 
       can be interpreted as computing E' given Γ and E as inputs
----------------------------------------------------------------------------------------------}%
LF nat_tp : tm → tp → type =
  | nt_const : nat_tp ( const n ) base
  | nt_app : nat_tp P ( pi A B )
             → nat_tp ( app P M ) ( B M )
  | nt_proj1 : nat_tp P ( sigma A B )
               → nat_tp ( proj1 P ) A
  | nt_proj2 : nat_tp P ( sigma A B ) 
               → nat_tp ( proj2 P ) ( B ( proj1 P ) )
;


LF head_red : tm → tm → type =
  | hr_beta : elim_ctx E 
              → head_red ( E ( app ( lam ( \x. M x ) ) M' ) ) ( E (M M') )
  | hr_proj1 : elim_ctx E
               → head_red ( E ( proj1 ( pair M M' ) ) ) ( E M )
  | hr_proj2 : elim_ctx E
               → head_red ( E ( proj2 ( pair M M' ) ) ) ( E M' )
  | hr_path : elim_ctx E 
              → nat_tp p ( sing N )
              → head_red ( E p ) ( E N )
;

LF not_possible  : type =
;

LF head_norm : tm → tm →  type =
  | hn_nostep : ( head_red M N → not_possible )
                → head_norm M M                                       % Not sure if this should only apply when M doesn't step  ??
  | hn_step : head_red M M' → head_norm M' N
              → head_norm M N
;


LF tm_norm : tm → tp → tm → type =
  | tmn_base : head_norm M M' → path_norm M' M'' base
               → tm_norm M base M''
  | tmn_sing : head_norm M M' → path_norm M' M'' ( sing N )
               → tm_norm M ( sing N ) M''
  | tmn_pi : tp_norm A A' → ( {x : tm } wt_tm x A → tm_norm ( app M x ) ( B x ) ( N x ) )
             → tm_norm M ( pi A B ) ( lam N )
  | tmn_sigma : tm_norm ( proj1 M ) A N → tm_norm ( proj2 M ) ( B ( proj1 M ) ) N'
                → tm_norm M ( sigma A B ) ( pair N N' )
                          
                          
and path_norm : tm → tm → tp → type =
  | pn_const : path_norm ( const n ) ( const n ) base
  %2 | pn_var : { x : tm } { t_x : wt_tm x A } path_norm x x A
  | pn_app : path_norm p p' ( pi A B ) → tm_norm M A M'
             → path_norm ( app p M ) ( app p' M' ) ( B M )
  | pn_proj1 : path_norm p p' ( sigma A B )
               → path_norm ( proj1 p ) ( proj1 p' ) A
  |pn_proj2 : path_norm p p' ( sigma A B )
              →  path_norm ( proj2 p ) ( proj2  p' ) ( B ( proj1 p ) )
                           
                           
and tp_norm : tp → tp → type =
  | tpn_base : tp_norm base base
  | tpn_sing : tm_norm M base M'
               → tp_norm ( sing M ) ( sing M' )
  | tpn_pi : tp_norm A A' → ( { x : tm } { t_x : wt_tm x A } tp_norm ( B x ) ( B' x ) )
             → tp_norm ( pi A B )  ( pi A' B' )
  | tpn_sigma : tp_norm A A' → ( { x : tm } { t_x : wt_tm x A } tp_norm ( B x ) ( B' x ) )
                → tp_norm ( sigma A B )  ( sigma A' B' )
;



%{----------------------------------------------------------------------------------------------
       Lemma 4.1 ( Determinacy )
             (1) If  Γ ⊢ p /\ A   and  Γ ⊢ p /\ B , then  A = B
             (+) If  Γ ⊢ M \/ N1  and  Γ ⊢ M \/ N2 ,  then N1 = N2                   ( * this is not in the paper, but I think it's needed for (2)  )
             (2) If  Γ ⊢ M : A ⇒ N1  and  Γ ⊢ M : A ⇒ N2 , then N1 = N2
             (3) If Γ ⊢ p → p1 /\ A1  and  Γ ⊢ p → p2 /\  A2 , then  A1 = A2
             (4) If Γ ⊢ A ⇒ B1  and  Γ ⊢ A ⇒ B2 , then  B1 = B2

        * What notion of equality is used in this?
            I think it's just defined by reflexivity ( up to renaming of bound variables )
----------------------------------------------------------------------------------------------}%
LF tm_eq  : tm → tm → type =
  | tm_refl : tm_eq M M
;

LF tp_eq  : tp → tp → type =
  | tp_refl : tp_eq A A
;


% 4.1 (1)
rec nat_tp_det : ( Γ : tctx ) [ Γ ⊢ nat_tp p A ] → [ Γ ⊢ nat_tp p B ]
                 → [ Γ ⊢ tp_eq A B ] =
/ total d ( nat_tp_det γ p a b d e ) /
fn d ⇒ fn e ⇒ case d of
  | [ Γ ⊢ nt_const ] ⇒ 
        let [ Γ ⊢ nt_const ] = e in 
        [ Γ ⊢ tp_refl ]
            
  | [ Γ ⊢ nt_app NT ] ⇒ 
        let [ Γ ⊢ nt_app NT' ] = e in 
        let [ Γ ⊢ tp_refl ] = nat_tp_det [ Γ ⊢ NT ] [ Γ ⊢ NT' ] in 
        [ Γ ⊢ tp_refl ]
            
  | [ Γ ⊢ nt_proj1 NT ] ⇒ 
        let [ Γ ⊢ nt_proj1 NT' ] = e in 
        let [ Γ ⊢ tp_refl ] = nat_tp_det [ Γ ⊢ NT ] [ Γ ⊢ NT' ] in 
        [ Γ ⊢ tp_refl ]
  | [ Γ ⊢ nt_proj2 NT ] ⇒
        let [ Γ ⊢ nt_proj2 NT' ] = e in 
        let [ Γ ⊢ tp_refl ] = nat_tp_det [ Γ ⊢ NT ] [ Γ ⊢ NT' ] in 
        [ Γ ⊢ tp_refl ]
;


% 4.1 (2)
rec tm_norm_det : ( Γ : tctx ) [ Γ ⊢ tm_norm M A N1 ] → [ Γ ⊢ tm_norm M A N2 ]
                  → [ Γ ⊢ tm_eq N1 N2 ] =
/ total d ( tm_norm_det γ m a n1 n2 d e ) /
fn d , e ⇒ case d of
  | [ Γ ⊢ tmn_base HN PN ] ⇒ 
        let [ Γ ⊢ tmn_base HN' PN' ] = e in ?

  | [ Γ ⊢ tmn_sing HN PN ] ⇒ 
        let [ Γ ⊢ tmn_sing HN' PN' ] = e in ?
                                                
  | [ Γ ⊢ tmn_pi TPN ( \x. \t. F ) ] ⇒ 
        let [ Γ ⊢ tmn_pi TPN' ( \x. \t. F' ) ] = e in ?
                                                          
  | [ Γ ⊢ tmn_sigma TMN1 TMN2 ] ⇒ 
        let [ Γ ⊢ tmn_sigma TMN1' TMN2' ] =  e in 
        let [ Γ ⊢ tm_refl ] = tm_norm_det [ Γ ⊢ TMN1 ] [ Γ ⊢ TMN1' ] in
        let [ Γ ⊢ tm_refl ] = tm_norm_det [ Γ ⊢ TMN2 ] [ Γ ⊢ TMN2' ] in 
        [ Γ ⊢ tm_refl ]
            
and 
% 4.1 (3)
% Term equality part
rec path_norm_det1 : ( Γ : tctx ) [ Γ ⊢ path_norm p p1 A1 ] → [ Γ ⊢ path_norm p p2 A2 ] 
                     → [ Γ ⊢ tm_eq p1 p2 ] =
/ total d ( path_norm_det1 γ p  p1 a1 p2 a2 d e ) /
fn d , e ⇒ case d of
  | [ Γ ⊢ pn_const ] ⇒
        let [ Γ ⊢ pn_const ] = e in 
        [ Γ ⊢ tm_refl ]

 % | [ Γ ⊢ pn_var x t_x  ] ⇒ ?
        
  | [ Γ ⊢ pn_app PN TMN ] ⇒
        let [ Γ ⊢ pn_app PN' TMN' ] = e in 
        let [ Γ ⊢ tm_refl ] = path_norm_det1 [ Γ ⊢ PN ] [ Γ ⊢ PN' ] in 
        let [ Γ ⊢ tp_refl ] = path_norm_det2 [ Γ ⊢ PN ] [ Γ ⊢ PN' ] in
        let [ Γ ⊢ tm_refl ] = tm_norm_det [ Γ ⊢ TMN ] [ Γ ⊢ TMN' ] in 
        [ Γ ⊢ tm_refl ]

  | [ Γ ⊢ pn_proj1 PN ] ⇒
        let [ Γ ⊢ pn_proj1 PN' ] = e in 
        let [ Γ ⊢ tm_refl ] = path_norm_det1 [ Γ ⊢ PN ] [ Γ ⊢ PN'] in 
        let [ Γ ⊢ tp_refl ] = path_norm_det2 [ Γ ⊢ PN ] [ Γ ⊢ PN'] in 
        [ Γ ⊢ tm_refl ]
        
  | [ Γ ⊢ pn_proj2 PN ] ⇒ 
        let [ Γ ⊢ pn_proj2 PN' ] = e in 
        let [ Γ ⊢ tm_refl ] = path_norm_det1 [ Γ ⊢ PN ] [ Γ ⊢ PN'] in 
        let [ Γ ⊢ tp_refl ] = path_norm_det2 [ Γ ⊢ PN ] [ Γ ⊢ PN'] in 
        [ Γ ⊢ tm_refl ]

and

% Type equality part
rec path_norm_det2 : ( Γ : tctx ) [ Γ ⊢ path_norm p p1 A1 ] → [ Γ ⊢ path_norm p p2 A2 ] 
                     → [ Γ ⊢ tp_eq A1 A2 ] =
/ total d ( path_norm_det2 γ p  p1 a1 p2 a2 d e ) /
fn d , e ⇒ case d of
  | [ Γ ⊢ pn_const ] ⇒
        let [ Γ ⊢ pn_const ] = e in 
        [ Γ ⊢ tp_refl ]

 % | [ Γ ⊢ pn_var x t_x  ] ⇒ ?
        
  | [ Γ ⊢ pn_app PN TMN ] ⇒
        let [ Γ ⊢ pn_app PN' TMN' ] = e in 
        let [ Γ ⊢ tp_refl ] = path_norm_det2 [ Γ ⊢ PN ] [ Γ ⊢ PN' ] in
        [ Γ ⊢ tp_refl ]

  | [ Γ ⊢ pn_proj1 PN ] ⇒
        let [ Γ ⊢ pn_proj1 PN' ] = e in 
        let [ Γ ⊢ tp_refl ] = path_norm_det2 [ Γ ⊢ PN ] [ Γ ⊢ PN'] in 
        [ Γ ⊢ tp_refl ]
        
  | [ Γ ⊢ pn_proj2 PN ] ⇒ 
        let [ Γ ⊢ pn_proj2 PN' ] = e in 
        let [ Γ ⊢ tp_refl ] = path_norm_det2 [ Γ ⊢ PN ] [ Γ ⊢ PN'] in 
        [ Γ ⊢ tp_refl ]



and
% 4.1 (4)
rec tp_norm_det : ( Γ : tctx ) [ Γ ⊢ tp_norm A B1 ] → [ Γ ⊢ tp_norm A B2 ]
                  → [ Γ ⊢ tp_eq B1 B2 ] =
/ total d ( tp_norm_det γ a b1 b2 d e ) /
fn d , e ⇒ case d of
  | [ Γ ⊢ tpn_base ] ⇒ 
        let [ Γ ⊢ tpn_base ] = e in 
        [ Γ ⊢ tp_refl ]

  | [ Γ ⊢ tpn_sing TMN ] ⇒ 
        let [ Γ ⊢ tpn_sing TMN' ] = e in
        let [ Γ ⊢ tm_refl ] = tm_norm_det [ Γ ⊢ TMN ] [ Γ ⊢ TMN' ] in
        [ Γ ⊢ tp_refl ]

  | [ Γ ⊢ tpn_pi TPN ( \x. \t. F ) ] ⇒ 
        let [ Γ ⊢ tpn_pi TPN' ( \x. \t. F' ) ] = e in 
        let [ Γ ⊢ tp_refl ] = tp_norm_det [ Γ ⊢ TPN ] [ Γ ⊢ TPN' ] in
        let [ Γ , b : ( block x : tm , t_x : wt_tm x A ) ⊢ tp_refl ] = tp_norm_det [  Γ , b : ( block x : tm , t_x : wt_tm x _ ) ⊢ F[.. , b.1,  b.2 ] ] 
                                                                                                                                      [  Γ , b : ( block x : tm , t_x : wt_tm x _ ) ⊢ F'[.. , b.1, b.2 ] ] in 
        [ Γ ⊢ tp_refl ]

  | [ Γ ⊢ tpn_sigma TPN ( \x. \t. F ) ] ⇒ 
        let [ Γ ⊢ tpn_sigma TPN' ( \x. \t. F' ) ] = e in 
        let [ Γ ⊢ tp_refl ] = tp_norm_det [ Γ ⊢ TPN ] [ Γ ⊢ TPN' ] in 
        let [ Γ , b : ( block x : tm , t_x : wt_tm x A ) ⊢ tp_refl ] = tp_norm_det [  Γ , b : ( block x : tm , t_x : wt_tm x _ ) ⊢ F[.. , b.1,  b.2 ] ] 
                                                                                                                                      [  Γ , b : ( block x : tm , t_x : wt_tm x _ ) ⊢ F'[.. , b.1, b.2 ] ] in 
        [ Γ ⊢ tp_refl ]
;

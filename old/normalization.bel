%{----------------------------------------------------------------------------------------------
           Algorithmic judgments for normalization of terms and types
               Source :   Stone, C.A.,  Harper, R. (2006). Extensional Equivalence and Singleton Types.  pp. 21-22.

               Author : Antoine Gaulin

--------------------------------------------------------------------------------------------------
  This section introduces "algorithmic" inference rules to compute normal forms of terms and types
  These new rules define six additional judgments in the language, which depend on the notions of 'elimination contexts' and 'paths'
      (1) An elimination is a series of applications to and projection from the context hole ( denoted <> )
            They are formally defined via the following syntax : 
                                           ε  ∷=  <>
                                                    | ε M
                                                    | π1 ε
                                                    | π2 ε
          Given an elimination context ε, we write ε[M] to denote the term resuting from filling <> with M
        
      (2) A path is any term of the form ε[x] of ε[c]
      
      
  And now, we can define the judgments :
      (1)    Γ ⊢ p /\ A                 Path p has natural type A                                           *  /\ represents an upward arrow
      (2)    Γ ⊢ M ~> M'            Term M head reduces to term M'
      (3)    Γ ⊢ M \/ N               Term M has head normal form N                                * \/ represents a downward arrow
      (4)    Γ ⊢ M : A ⇒ M'       Term M has normal form M' at type A
      (5)    Γ ⊢ p → p' /\ A        Path p has normal form p' at natural type A
      (6)    Γ ⊢ A ⇒ B                Type A has normal form B
----------------------------------------------------------------------------------------------}%


%----------------------------------------
% Natural typing
%----------------------------------------
inductive nat_tp : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tp ] → ctype =
  | nt_const : nat_tp [ Γ ⊢ const n ] [ Γ ⊢ base ]
  | nt_var : nat_tp [ Γ ⊢  #b.1 ]  [ Γ ⊢ #b.2 ]
  | nt_proj1 : nat_tp [ Γ ⊢ p ] [ Γ ⊢ sigma A ( \x. B ) ]
                       → nat_tp [ Γ ⊢ proj1 p ] [ Γ ⊢ A ]
  | nt_proj2 : nat_tp [ Γ ⊢ p ] [ Γ ⊢ sigma A ( \x. B ) ]
                       → nat_tp [ Γ ⊢ proj2 p ] [ Γ ⊢ B[.., (proj1 p)] ]
  | nt_app : nat_tp [ Γ ⊢ p ] [ Γ ⊢ pi A (\x. B ) ]
                     → nat_tp [ Γ ⊢ app p M ] [ Γ ⊢ B[.. , M ] ]
;


%----------------------------------------
% Head Reductions
%----------------------------------------

% Head reductions are encoded using elimination contexts
LF elim_ctx : ( tm → tm ) → type =
  | e_hole : elim_ctx ( \x. x )
  | e_app : elim_ctx E
            → { M : tm } elim_ctx ( \x. app ( E x ) M )
  | e_proj1 : elim_ctx E 
              → elim_ctx ( \x. proj1 ( E x ) )
  | e_proj2 : elim_ctx E
              → elim_ctx ( \x. proj2 ( E x ) )
;


% We define equality of terms so that we can represent factorizations : M = ε[M']
LF tm_eq : tm → tm → type =
  | tm_refl : tm_eq M M
;

% And we use such factorizations in the definition of head reductions :
inductive head_red : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tm ] → ctype =
  | hr_beta : { E' : [ Γ, x : tm ⊢ tm ] } { E : [ Γ  ⊢ elim_ctx ( \x. E' ) ] } 
              [ Γ ⊢ tm_eq M E'[.., app ( lam A ( \x. M1 ) ) M2 ] ] → [ Γ ⊢ tm_eq M' ( E'[.., M1[..,M2]] ) ]
              → head_red [ Γ ⊢ M ] [ Γ ⊢ M' ]

  | hr_proj1 : { E' : [ Γ, x : tm ⊢ tm ] } { E : [ Γ  ⊢ elim_ctx ( \x. E' ) ] } 
               [ Γ ⊢ tm_eq M E'[.., proj1 ( pair M1 M2 )] ] → [ Γ ⊢ tm_eq M' E'[.., M1] ]
               → head_red [ Γ ⊢ M ] [ Γ ⊢ M' ]

  | hr_proj2 : { E' : [ Γ, x : tm ⊢ tm ] } { E : [ Γ  ⊢ elim_ctx ( \x. E' ) ] } 
               [ Γ ⊢ tm_eq M E'[.., proj2 ( pair M1 M2 )] ] → [ Γ ⊢ tm_eq M' E'[.., M2] ]
               → head_red [ Γ ⊢ M ] [ Γ ⊢ M' ]

  |hr_path : { E' : [ Γ, x : tm ⊢ tm ] } { E : [ Γ  ⊢ elim_ctx ( \x. E' ) ] } 
             → [ Γ ⊢ tm_eq M E'[.., P] ] → [ Γ ⊢ tm_eq M' E'[.., N] ] 
             → nat_tp [ Γ ⊢ P ] [ Γ ⊢ sing N ]
             → head_red [ Γ ⊢ M ] [ Γ ⊢ M' ]
;


%----------------------------------------
%  Head Normalization
%----------------------------------------
% The head normalization jugment  Γ ⊢ M \/ N  depends on whether the term  M can step or not
% So, to define it, we will need an empty type
LF not_possible : type =
;

inductive head_norm : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tm ] → ctype =
  | hn_step : head_red [ Γ ⊢ M ] [ Γ ⊢ M' ] → head_norm [ Γ ⊢ M' ] [ Γ ⊢ N ]
              → head_norm [ Γ ⊢ M ] [ Γ ⊢ N ]
  | hn_nostep : ( { N : [ Γ ⊢ tm ] } head_red [ Γ ⊢ M ] [ Γ ⊢ N ] → [ Γ ⊢ not_possible ] )     % If M ~> N is impossible for all N, then M is already in head normal form
                → head_norm [ Γ ⊢ M ] [ Γ ⊢ M ]
;


%----------------------------------------
%  Term, Path, and Type Normalization
%----------------------------------------
inductive tm_norm : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tp ] → [ Γ ⊢ tm ] → ctype =
  | tmn_base : head_norm [ Γ ⊢ M ] [ Γ ⊢ M' ] 
               → path_norm [ Γ ⊢ M' ] [ Γ ⊢ M'' ] [ Γ ⊢ base ]
               → tm_norm [ Γ ⊢ M ] [ Γ ⊢ base ] [ Γ ⊢ M'' ]
                         
  | tmn_sing : head_norm [ Γ ⊢ M ] [ Γ ⊢ M' ] 
               → path_norm [ Γ ⊢ M' ] [ Γ ⊢ M'' ] [ Γ ⊢ sing N ]
               → tm_norm [ Γ ⊢ M ] [ Γ ⊢ sing N ] [ Γ ⊢ M'' ]
                         
  | tmn_pi : tp_norm [ Γ ⊢ A ] [ Γ ⊢ A' ] 
             → tm_norm [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ app M[..] b.1 ]
                       [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B[..] ]
                       [ Γ , b : block ( x : tm , A : tp  , t_x : wt_tm x A ) ⊢ N[.., b.1] ]
             → tm_norm [ Γ ⊢ M[..] ] [ Γ ⊢ pi A ( \x. B[..] ) ] [ Γ ⊢ lam A' ( \x. N[..] ) ]
                       
  | tmn_sigma : tm_norm [ Γ ⊢ proj1 M ] [ Γ ⊢ A ] [ Γ ⊢ N1 ]
                → tm_norm [ Γ ⊢ proj2 M ] [ Γ ⊢ B[.., proj1 M ] ] [ Γ ⊢ N2 ]
                → tm_norm [ Γ ⊢ M ] [ Γ ⊢ sigma A ( \x. B ) ] [ Γ ⊢ pair N1 N2 ]
                          
                          
and inductive path_norm : ( Γ : tctx ) [ Γ ⊢ tm ] → [ Γ ⊢ tm ] → [ Γ ⊢ tp ] → ctype =
      | pn_const : path_norm [ Γ ⊢ const n ] [ Γ ⊢ const n ] [ Γ ⊢ base ]
      | pn_var : path_norm [ Γ ⊢ #b.1 ] [ Γ ⊢ #b.1 ] [ Γ ⊢ #b.2 ]
                 
      | pn_app : path_norm [ Γ ⊢ p  ] [ Γ ⊢ p' ] [ Γ ⊢ pi A ( \x. B ) ]
                 → tm_norm [ Γ ⊢ M ] [ Γ ⊢ A ] [ Γ ⊢ M' ]
                 → path_norm [ Γ ⊢ app p M ] [ Γ ⊢ app p' M' ] [ Γ ⊢ B[.., M] ]
                             
      | pn_proj1 : path_norm  [ Γ ⊢ p ] [ Γ ⊢ p' ] [ Γ ⊢ sigma A ( \x. B ) ]
                   → path_norm [ Γ ⊢ proj1 p ]  [ Γ ⊢ proj1 p' ] [ Γ ⊢ A ]
                               
      | pn_proj2 : path_norm [ Γ ⊢ p ] [ Γ ⊢ p' ] [ Γ ⊢ sigma A ( \x. B ) ] 
                   → path_norm [ Γ ⊢ proj2 p ] [ Γ ⊢ proj2 p' ] [ Γ ⊢ B[.., p] ]
                               
                               
and inductive tp_norm : ( Γ : tctx ) [ Γ ⊢ tp ] → [ Γ ⊢ tp ] → ctype = 
      | tpn_base : tp_norm [ Γ ⊢ base ] [ Γ ⊢ base ]
                   
      | tpn_sing : tm_norm [ Γ ⊢ M ] [ Γ ⊢ base ] [ Γ ⊢ M' ]
                   → tp_norm [ Γ ⊢ sing M ] [ Γ ⊢ sing M' ]
                             
      | tpn_pi : tp_norm [ Γ ⊢ A ] [ Γ ⊢ A' ]
                 → tp_norm [ Γ, b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B[.., b.1 ] ] [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B'[.., b.1] ]
                 → tp_norm [ Γ ⊢ pi A ( \x. B ) ] [ Γ ⊢ pi A' ( \x. B' ) ]
                           
      | tpn_sigma :  tp_norm [ Γ ⊢ A ] [ Γ ⊢ A' ]
                     → tp_norm [ Γ, b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B[.., b.1 ] ] [ Γ , b : block ( x : tm , A : tp , t_x : wt_tm x A ) ⊢ B'[.., b.1] ]
                     → tp_norm [ Γ ⊢ sigma A ( \x. B ) ] [ Γ ⊢ sigma A' ( \x. B' ) ]
;




% This is for later
LF tp_eq : tp → tp → type =
  | tp_refl : tp_eq M M
;

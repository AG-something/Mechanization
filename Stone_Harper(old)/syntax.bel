%{----------------------------------------------------------------------------------------------
        Syntax and inference rules of a dependently-typed λ-calculus with unit types and subtyping
               Source :   Stone, C.A.,  Harper, R. (2006). Extensional Equivalence and Singleton Types.  pp. 4-14.

               Author : Antoine Gaulin

--------------------------------------------------------------------------------------------------
  Syntax of expressions
     Typing Contexts    Γ, Δ ∷=   ε            Empty context
                                                   | Γ, x:A       Context extension

     Types                      A, B ∷=   b            Base type 
                                                   | S(M)         Singleton type
		                         	   | S_A(M)       Labelled singleton type  (admissible)
                				   | Πx:A. A'     Dependent function type
		                    		   | Σx:A. A'     Dependent pair type

     Terms                     M, N ∷=   c_i          Constants
           		                           | x_i          Variables
				                   | λx:A. M      Function abstraction
                                                   | M M'         Function application
				                   | <M, M'>      Pairs
				                   | π_i(M)       Projections
----------------------------------------------------------------------------------------------}%
% The terms and types can be defined by simultaneous induction
% The contexts will have to wait after the typing judgment is defined.

% Types
LF etp : type =
  | e_base : etp
  % Dependent types
  | e_pi : etp → ( etm → etp ) → etp
  | e_sigma : etp → ( etm → etp ) → etp
  % Singleton types
  | e_sing : etm → etp
  | e_sing_lab : etp → etm → etp
			       
% Terms
and etm : type =
  | e_cons : nat → etm
  % Functions
  | e_lam : etp → ( etm → etm ) → etm
  | e_app : etm → etm → etm
  % Pairs
  | e_pair : etm → etm → etm
  | e_proj1 : etm → etm
  | e_proj2 : etm → etm
;


%{---------------------------------------------------------------------------------------------
    Judgments :
               Well-formed types                          Γ ⊢ A
               Subtypes                                           Γ ⊢ A < B
               Declarative equality of types        Γ ⊢ A == B

               Well-typed terms                             Γ ⊢ M : A
               Declarative equality of terms        Γ ⊢ M == N : A

               Well-formed context                       Γ ⊢ ok
                 * This should all be taken care of by Beluga
----------------------------------------------------------------------------------------------}%

% Well-formed types        Γ ⊢ A
LF wf_etp : etp → type =
  | wf_base : wf_etp e_base
  % Dependent
  | wf_pi : ( { x : etm } wf_etm x A → wf_etp B )
	    → wf_etp (e_pi A _ )
  | wf_sigma : ( { x : etm } wf_etm x A → wf_etp B )
	       → wf_etp (e_sigma A _ )
  % Singletons
  | wf_sing : wf_etm M e_base
	      → wf_etp ( e_sing M )
  | wf_sing_lan : wf_etm M A
		  → wf_etp ( e_sing_lab A M )
			   
% Subtypes        Γ ⊢ A < B
and e_sub : etp → etp → type =
  | sub_base : e_sub e_base e_base
  % Dependent
  | sub_pi : wf_etp ( e_pi A1 ( \x. B1 x ) )
	     → e_sub A2 A1 → ( { x : etm } wf_etm x A2 → e_sub ( B1 x ) ( B2 x ) )
	     → e_sub ( e_pi A1 ( \x. B1 x ) ) ( e_pi A2 ( \x. B2 x ) )
  | sub_sigma : wf_etp ( e_sigma A1 ( \x. B1 x ) )
		→ e_sub A2 A1 → ( { x : etm } wf_etm x A2 → e_sub ( B2 x ) ( B1 x ) )
		→ e_sub ( e_sigma A2 ( \x. B2 x ) ) ( e_sigma A1 ( \x. B1 x ) )
  % Singletons
  | sub_sing : wf_etm M e_base
	       → e_sub ( e_sing M ) e_base
  | sub_sing_lab1 : wf_etm M A
		    → e_sub ( e_sing_lab A M ) A
  | sub_sing_lab2 : eq_etm M N A → e_sub A B
		    → e_sub ( e_sing_lab A M ) ( e_sing_lab B N )
  | sub_eq : eq_etm M N e_base
	     → e_sub ( e_sing M ) ( e_sing N )
		     
% Declarative equality of types      Γ ⊢ A == B
and eq_etp : etp → etp → type =
  | eq_base : eq_etp e_base e_base
  % Dependent
  | eq_pi : eq_etp A1 A2 → ( { x : etm } wf_etm x A1 → eq_etp ( B1 x ) ( B2 x ) )
	    → eq_etp ( e_pi A1 ( \x. B1 x ) ) ( e_pi A2 ( \x. B2 x ) )
  | eq_sigma : eq_etp A1 A2 → ( { x : etm } wf_etm x A1 → eq_etp ( B1 x ) ( B2 x ) )
	       → eq_etp ( e_sigma A1 ( \x. B1 x ) ) ( e_sigma A2 ( \x. B2 x ) )
  % Singleton
  | eq_sing : eq_etm M N e_base
	      → eq_etp ( e_sing M ) ( e_sing N )

% Well-typed terms       Γ ⊢ M : A
and wf_etm : etm → etp → type =
  | wf_cons : { i : nat } wf_etm ( e_cons i ) e_base
  | wf_sub : wf_etm M A → e_sub A B
	     → wf_etm M B
  % Rules for Π-types correspond to rules of implication
  | wf_lam : ( { x : etm } wf_etm x A → wf_etm ( M x ) ( B x ) )
	     → wf_etm ( e_lam A M ) ( e_pi A B )
  | wf_app : wf_etm M ( e_pi A ( \x. B x) ) → wf_etm N A
	     → wf_etm ( e_app M N ) ( B M )
  | wf_depf : ( { x : etm } wf_etm x A → wf_etm ( e_app M x ) ( B' x ) )
	      → wf_etm M ( e_pi A ( \x. B x ) ) → wf_etp ( e_pi A ( \x. B x ) )
	      → wf_etm M ( e_pi A ( \x. B' x ) )
  % Rules for Σ-types correspond to rules of conjunction, except that the second of the pair depends on the first
  | wf_pair : wf_etp ( e_sigma A ( \x. B x ) )
	      → wf_etm M A → wf_etm N ( B M )
	      → wf_etm ( e_pair M N ) ( e_sigma A ( \x. B x ) )
  | wf_proj1 : wf_etm M ( e_sigma A ( \x. B x ) )
	       → wf_etm ( e_proj1 M ) A
  | wf_proj2 : wf_etm M ( e_sigma A ( \x. B x ) )
	       → wf_etm ( e_proj2 M ) ( B ( e_proj1 M ) )
  | wf_depp : wf_etp ( e_sigma A ( \x. B x ) )
	      → wf_etm ( e_proj1 M ) A → wf_etm ( e_proj2 M ) ( B ( e_proj1 M ) )

  % Singletons
  | wf_etm_sing : wf_etm M e_base
		  → wf_etm M ( e_sing M )
  | wf_etm_sing_lab : wf_etm M A
		      → wf_etm M ( e_sing_lab A M )

  | wf_sing_intro : eq_etm M N e_base
		→ wf_etm M ( e_sing N )
  
% Declarative equality of terms     Γ ⊢ M == N : A
and eq_etm : etm → etm → etp → type =
  % Axioms of equivalence relation
  | eq_refl : wf_etm M A → eq_etm M M A
  | eq_sym : eq_etm M N A → eq_etm N M A
  | eq_tran : eq_etm M1 M2 A → eq_etm M2 M3 A → eq_etm M1 M3 A

  % Dependent functions
  | eq_lam : eq_etp A1 A2 → ( { x : etm } wf_etm x A1 → eq_etm ( M1 x ) ( M2 x ) ( B x ) )
	     → eq_etm ( e_lam A1 ( \x. M1 x ) ) ( e_lam A2 ( \x. M2 x ) ) ( e_pi A1 ( \x. B x ) ) 
  | eq_app : eq_etm M1 M2 ( e_pi A ( \x. B x ) ) → eq_etm N1 N2 A
	     → eq_etm ( e_app M1 N1 ) ( e_app M2 N2 ) ( B M1 )
  | eq_fn : ( { x : etm } wf_etm x A → eq_etm ( e_app M1 x ) ( e_app M2 x ) ( B x ) )
	    → wf_etm M1 ( e_pi A ( \x. C1 x ) ) → wf_etm M2 ( e_pi A ( \x. C2 x ) )
	    → eq_etm M1 M2 ( e_pi A ( \x. B x ) )
  
  % Dependent pairs
  | eq_proj1 : eq_etm M1 M2 ( e_sigma A ( \x. B x ) )
	       → eq_etm ( e_proj1 M1 ) ( e_proj1 M2 ) A
  | eq_proj2 : eq_etm M1 M2 ( e_sigma A ( \x. B x ) )
	       → eq_etm ( e_proj2 M1 ) ( e_proj2 M2 ) ( B ( e_proj1 M1 ) )
  | eq_pair1 : wf_etp ( e_sigma A ( \x. B x ) )
	      → eq_etm M1 M2 A → eq_etm N1 N2 ( B M1 )
	      → eq_etm ( e_pair M1 N1 ) ( e_pair M2 N2 ) ( e_sigma A ( \x. B x ) )
  | eq_pair2 : wf_etp ( e_sigma A ( \x. B x ) )
	       → eq_etm ( e_proj1 M ) ( e_proj1 N ) A → eq_etm ( e_proj2 M ) ( e_proj2 N ) ( B ( e_proj1 M ) )
	       → eq_etm M N ( e_sigma A ( \x. B x ) )

  % Subtypes
  | eq_sub : eq_etm M N A → e_sub A B
	     → eq_etm M N B

  % Singleton (all admissible except eq_sing)
  | eq_sing : wf_etm M ( e_sing N )
	      → eq_etm M N ( e_sing N )

  | eq_sing_intro : eq_etm M N e_base
		    → eq_etm M N ( e_sing N )
  | eq_sing_elim : wf_etm M ( e_sing N )
		   → eq_etm M N e_base

  | eq_sing_lab1 : wf_etm M A → wf_etm M ( e_sing_lab A N )
		   → eq_etm M N ( e_sing_lab A N )
  | eq_sing_lab2 : eq_etm M N A
		   → eq_etm M N ( e_sing_lab A N )

  % β-reduction rules (admissible)
  | eq_beta_lam : ( { x : etm } wf_etm x A → wf_etm ( M x ) ( B x ) ) → wf_etm N A
		  → eq_etm ( e_app ( e_lam A ( \x. M x ) ) N ) ( M N ) ( B N )
  | eq_beta_pair1 : wf_etm M A → wf_etm N B
		    → eq_etm ( e_proj1 ( e_pair M N ) ) M A
  | eq_beta_pair2 : wf_etm M A → wf_etm N B
		    → eq_etm ( e_proj2 ( e_pair M N ) ) N B

  % η-expansion rules (admissible)
  | eq_eta_lam : wf_etm M ( e_pi A ( \x. B x ) )
		 → eq_etm M ( e_lam A ( \x. e_app M x ) ) ( e_pi A ( \x. B x ) )
  | eq_eta_pair : wf_etm M ( e_sigma A ( \x. B x ) )
		  → eq_etm M ( e_pair ( e_proj1 M ) ( e_proj2 M ) ) ( e_sigma A ( \x. B x ) )
;


% Finally we can define (well-formed) typing contexts
schema tctx = some [ t : etp ] block ( x : etm , t_x : wf_etm x t );


% It may be useful (read cleaner) later on to have a type for all judgments
LF judg : type =
  | j_wf_tp : wf_etp A → judg                    % Γ ⊢ A
  | j_sub : e_sub A B → judg                       % Γ ⊢ A < B
  | j_eq_tp : eq_etp A B  → judg               % Γ ⊢ A == B

  | j_wf_tm : wf_etm M A → judg              % Γ ⊢ M : A
  | j_eq_tm : eq_etm M N A → judg         % Γ ⊢ M == N : A
;
